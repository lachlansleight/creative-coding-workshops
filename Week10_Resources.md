# Week 10

### Resources

  * [Intro to Compute Shaders - Arsiliath](https://www.youtube.com/watch?v=V-yqiLyU27U) - A nice viewo explaining the theory behind compute shaders - how structured buffers work, how thread group dispatches work, etc. If you're serious about using compute shaders, this is a great video to start with. He also goes into Unity implementation!
  * [Getting Started with Compute Shaders in Unity - Game Dev Guide](https://www.youtube.com/watch?v=BrZ4pWwkpto) - A slightly slower, more implementation-focused breakdown of compute shaders. Note that this video specifically goes into using compute shaders to perform operations on textures, rather than structured buffers, which is equally, if not more common than operating on structured buffers.
  * [Compute Shaders - CatlikeCoding](https://catlikecoding.com/unity/tutorials/basics/compute-shaders/) - The most thorough, full explanation of compute shaders and their use in Unity.
  * [How do Games Render So Much Grass? - Acerola](https://www.youtube.com/watch?v=Y0Ko0kvwfgA) - While not specifically related to compute shaders per se, this is the best video (this, and the video following it) that explains the actual practice of using GPU data to create visuals in actual games. The link between GPU Instancing and compute shaders is the various `Graphics.DrawMeshInstanced` functions. See below!
  * [Between Tech and Art: The Vegetation of Horizon Zero Dawn](https://www.youtube.com/watch?v=wavnKZNSYqU) - I've watched this talk several times, just a great talk about tech-art and how we can work at the intersection of hand-created assets, simulation and procedural animation to create beautiful visuals. The part about tree vertex colors definining hierarchies is my favourite!

### Handy Tools from This Week

  * [ComputeShader](https://docs.unity3d.com/ScriptReference/ComputeShader.html) - Once you've gone through a tutorial or two above, you can use this page to get a fuller understanding of what the ComputeShader class can do.
  * [ComputeBuffer](https://docs.unity3d.com/ScriptReference/ComputeBuffer.html) - ComputeShaders operate on one of two things - a RenderTexture (See the second tutorial above), or a ComputeBuffer, which is what we did in class.
  * [Graphics.DrawMeshInstanced](https://docs.unity3d.com/ScriptReference/Graphics.DrawMeshInstanced.html) - When you have a ComputeBuffer that contains per-instance information (e.g. grass, particles, etc), you can use this function to draw many instances of a given mesh, using the ComputeBuffer to set individual mesh properties in the shader. See the work we did in-class for the details on how to do this.
  * [Graphics.DrawProcedural](https://docs.unity3d.com/ScriptReference/Graphics.DrawProcedural.html) - Other times, you'll want to draw one single object using the ComputeBuffer information to control individual vertices (e.g. a fluid / cloth simulation or some other very complex, dynamic object). This method is how this is achieved. The tricky part is controlling the mapping between vertex index and compute buffer index - generally you will want to create the Mesh with code directly so that you can control this mapping yourself. [Keijiro has a useful repo that demonstrates how this is done](https://github.com/keijiro/NoiseBall3).
  * [numthreads](https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-attributes-numthreads) - The Microsoft documentation page for how thread groups work. This is a super mind-bender, but if you ever want to do anything more complex than what we did in class, you'll need to wrap your noodle around this page.